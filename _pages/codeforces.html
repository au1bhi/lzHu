---
layout: single
title: "Codeforces Analytics"
permalink: /codeforces/
author_profile: true
---

{% include base_path %}

<div class="codeforces-dashboard">
    <p id="cf-status" class="cf-status">Loading Codeforces data...</p>
    <div class="cf-metrics" id="cf-metrics">
        <div class="cf-metric">
            <span class="cf-metric__label">Current Rating</span>
            <span class="cf-metric__value" id="cf-current-rating">--</span>
        </div>
        <div class="cf-metric">
            <span class="cf-metric__label">Peak Rating</span>
            <span class="cf-metric__value" id="cf-max-rating">--</span>
        </div>
        <div class="cf-metric">
            <span class="cf-metric__label">Total Submissions</span>
            <span class="cf-metric__value" id="cf-total-submissions">--</span>
        </div>
        <div class="cf-metric">
            <span class="cf-metric__label">Problems Solved</span>
            <span class="cf-metric__value" id="cf-solved-count">--</span>
        </div>
    </div>
    <div class="chart-grid">
        <div class="chart-card">
            <h3>Rating Trend</h3>
            <canvas id="cf-rating-chart" height="260"></canvas>
        </div>
        <div class="chart-card">
            <h3>Verdict Distribution</h3>
            <canvas id="cf-verdict-chart" height="260"></canvas>
        </div>
        <div class="chart-card">
            <h3>Difficulty Breakdown</h3>
            <canvas id="cf-difficulty-chart" height="260"></canvas>
        </div>
        <div class="chart-card">
            <h3>Accepted Tags Focus</h3>
            <canvas id="cf-tag-chart" height="260"></canvas>
        </div>
    </div>
</div>

<style>
    .codeforces-dashboard {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .cf-status {
        font-style: italic;
        color: var(--global-text-color, #555);
    }

    .cf-metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1rem;
    }

    .cf-metric {
        border: 1px solid var(--global-border-color, #e0e0e0);
        border-radius: 8px;
        padding: 0.75rem 1rem;
        background-color: var(--global-bg-color, #ffffff);
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.04);
        transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .cf-metric__label {
        display: block;
        font-size: 0.85rem;
        color: var(--global-text-color-light, #666);
    }

    .cf-metric__value {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--global-text-color, #111);
    }

    .chart-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1.5rem;
    }

    .chart-card {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        border: 1px solid var(--global-border-color, #dfe3eb);
        border-radius: 12px;
        padding: 1rem;
        background-color: var(--global-bg-color, #ffffff);
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
        min-height: 320px;
        transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .chart-card h3 {
        margin: 0;
        font-size: 1.1rem;
        color: var(--global-text-color, #111);
    }

    .chart-card canvas {
        flex: 1 1 auto;
        width: 100% !important;
        max-height: 260px;
    }

    html[data-theme="dark"] .cf-metric {
        background-color: var(--global-bg-color, #1f2937);
        border-color: var(--global-dark-border-color, rgba(255, 255, 255, 0.12));
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    }

    html[data-theme="dark"] .chart-card {
        background-color: var(--global-bg-color, #1f2937);
        border-color: var(--global-dark-border-color, rgba(255, 255, 255, 0.1));
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
<script>
    (function () {
        const handle = "Au1Bhi";
        const statusEl = document.getElementById("cf-status");
        const currentRatingEl = document.getElementById("cf-current-rating");
        const maxRatingEl = document.getElementById("cf-max-rating");
        const totalSubmissionsEl = document.getElementById("cf-total-submissions");
        const solvedCountEl = document.getElementById("cf-solved-count");

        const ratingCtx = document.getElementById("cf-rating-chart");
        const verdictCtx = document.getElementById("cf-verdict-chart");
        const difficultyCtx = document.getElementById("cf-difficulty-chart");
        const tagCtx = document.getElementById("cf-tag-chart");

        const userInfoUrl = `https://codeforces.com/api/user.info?handles=${handle}`;
        const ratingUrl = `https://codeforces.com/api/user.rating?handle=${handle}`;
        const statusUrl = `https://codeforces.com/api/user.status?handle=${handle}&from=1&count=1000`;

        const palettes = {
            blue: ["#2563eb", "#1d4ed8", "#3b82f6", "#60a5fa", "#93c5fd", "#bfdbfe"],
            green: ["#047857", "#059669", "#10b981", "#34d399", "#6ee7b7", "#a7f3d0"],
            slate: ["#0f172a", "#1e293b", "#334155", "#475569", "#64748b", "#94a3b8"]
        };

        const fetchJson = async (url) => {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Request failed: ${response.status}`);
            }
            const payload = await response.json();
            if (payload.status !== "OK") {
                throw new Error(payload.comment || "Codeforces API returned an error");
            }
            return payload.result;
        };

        const toDateLabel = (unixSeconds) => {
            return new Date(unixSeconds * 1000).toLocaleDateString(undefined, { year: "numeric", month: "short" });
        };

        const buildChart = (ctx, config) => new Chart(ctx, config);

        const paletteCycle = (paletteName, count) => {
            const base = palettes[paletteName] || palettes.blue;
            const colors = [];
            for (let i = 0; i < count; i += 1) {
                colors.push(base[i % base.length]);
            }
            return colors;
        };

        const init = async () => {
            if (typeof Chart === "undefined") {
                statusEl.textContent = "Failed to load data: Chart library unavailable";
                console.error("Chart.js failed to load.");
                return;
            }
            try {
                const [userInfo, ratingHistory, submissions] = await Promise.all([
                    fetchJson(userInfoUrl),
                    fetchJson(ratingUrl),
                    fetchJson(statusUrl)
                ]);

                const profile = userInfo[0] || {};
                currentRatingEl.textContent = profile.rating ?? "Unrated";
                maxRatingEl.textContent = profile.maxRating ?? "Unrated";

                const totalSubmissions = submissions.length;
                const solvedProblemIds = new Set();
                const verdictCounts = new Map();
                const tagCounts = new Map();
                const difficultyBuckets = new Map();

                const verdictColors = {
                    OK: "#10b981",
                    WRONG_ANSWER: "#ef4444",
                    TIME_LIMIT_EXCEEDED: "#fb923c",
                    MEMORY_LIMIT_EXCEEDED: "#14b8a6",
                    RUNTIME_ERROR: "#6366f1",
                    COMPILATION_ERROR: "#facc15",
                    SKIPPED: "#94a3b8",
                    CHALLENGED: "#f59e0b",
                    PARTIAL: "#22d3ee",
                    IDLENESS_LIMIT_EXCEEDED: "#7c3aed",
                    PRESENTATION_ERROR: "#8b5cf6",
                    HACK_SUCCESSFUL: "#f472b6",
                    HACK_UNSUCCESSFUL: "#c084fc"
                };

                const getDifficultyBucket = (rating) => {
                    if (typeof rating !== "number" || Number.isNaN(rating)) {
                        return "Unrated";
                    }
                    if (rating < 1200) return "<1200";
                    if (rating < 1400) return "1200-1399";
                    if (rating < 1600) return "1400-1599";
                    if (rating < 1800) return "1600-1799";
                    if (rating < 2000) return "1800-1999";
                    if (rating < 2200) return "2000-2199";
                    if (rating < 2400) return "2200-2399";
                    return "2400+";
                };

                const difficultyOrder = [
                    "<1200",
                    "1200-1399",
                    "1400-1599",
                    "1600-1799",
                    "1800-1999",
                    "2000-2199",
                    "2200-2399",
                    "2400+",
                    "Unrated"
                ];

                submissions.forEach((submission) => {
                    const verdict = submission.verdict || "UNKNOWN";
                    verdictCounts.set(verdict, (verdictCounts.get(verdict) || 0) + 1);

                    const problem = submission.problem || {};
                    const rating = Number.isFinite(problem.rating) ? problem.rating : undefined;
                    const problemKey = (problem.contestId && problem.index)
                        ? `${problem.contestId}-${problem.index}`
                        : undefined;
                    const bucket = getDifficultyBucket(rating);
                    if (!difficultyBuckets.has(bucket)) {
                        difficultyBuckets.set(bucket, {
                            attempted: new Set(),
                            solved: new Set()
                        });
                    }
                    const bucketEntry = difficultyBuckets.get(bucket);
                    if (problemKey) {
                        bucketEntry.attempted.add(problemKey);
                    }

                    if (verdict === "OK") {
                        const solvedKey = problemKey || `${submission.id}`;
                        if (problemKey) {
                            bucketEntry.solved.add(problemKey);
                        }
                        solvedProblemIds.add(solvedKey);
                        (submission.problem.tags || []).forEach((tag) => {
                            tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
                        });
                    }
                });

                totalSubmissionsEl.textContent = totalSubmissions;
                solvedCountEl.textContent = solvedProblemIds.size;

                const ratingLabels = ratingHistory.map((entry) => toDateLabel(entry.ratingUpdateTimeSeconds));
                const ratingValues = ratingHistory.map((entry) => entry.newRating);
                const ratingChanges = ratingHistory.map((entry) => entry.newRating - entry.oldRating);
                const ratingPointColors = ratingChanges.map((delta) => (delta >= 0 ? "#10b981" : "#f97316"));

                if (ratingHistory.length > 0) {
                    buildChart(ratingCtx, {
                        type: "line",
                        data: {
                            labels: ratingLabels,
                            datasets: [
                                {
                                    label: "Rating",
                                    data: ratingValues,
                                    borderColor: "#10b981",
                                    borderWidth: 2,
                                    segment: {
                                        borderColor: (ctx) => {
                                            const index = ctx.p0DataIndex + 1;
                                            if (index >= ratingChanges.length) {
                                                return "#10b981";
                                            }
                                            return ratingChanges[index] >= 0 ? "#10b981" : "#f97316";
                                        }
                                    },
                                    backgroundColor: "rgba(16, 185, 129, 0.16)",
                                    tension: 0.25,
                                    fill: true,
                                    pointRadius: 4,
                                    pointHoverRadius: 5,
                                    pointBackgroundColor: ratingPointColors,
                                    pointBorderColor: ratingPointColors,
                                    pointBorderWidth: 0
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: (items) => items[0]?.label ?? "",
                                        label: (context) => `Rating: ${context.parsed.y}`
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 8 }
                                },
                                y: {
                                    beginAtZero: false,
                                    ticks: { precision: 0 }
                                }
                            }
                        }
                    });
                }

                const verdictEntries = Array.from(verdictCounts.entries()).sort((a, b) => b[1] - a[1]);
                if (verdictEntries.length > 0) {
                    const defaultVerdictPalette = paletteCycle("green", verdictEntries.length);
                    buildChart(verdictCtx, {
                        type: "doughnut",
                        data: {
                            labels: verdictEntries.map(([verdict]) => verdict),
                            datasets: [
                                {
                                    data: verdictEntries.map(([, count]) => count),
                                    backgroundColor: verdictEntries.map(([verdict], index) => verdictColors[verdict] || defaultVerdictPalette[index]),
                                    borderWidth: 0
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { position: "bottom" }
                            }
                        }
                    });
                }

                const difficultyLabels = difficultyOrder.filter((label) => difficultyBuckets.has(label));
                if (difficultyLabels.length > 0) {
                    const solvedByBucket = difficultyLabels.map((label) => difficultyBuckets.get(label).solved.size);
                    const attemptedByBucket = difficultyLabels.map((label) => difficultyBuckets.get(label).attempted.size);

                    buildChart(difficultyCtx, {
                        type: "bar",
                        data: {
                            labels: difficultyLabels,
                            datasets: [
                                {
                                    label: "Solved Problems",
                                    data: solvedByBucket,
                                    backgroundColor: "#22c55e"
                                },
                                {
                                    label: "Attempted Problems",
                                    data: attemptedByBucket,
                                    backgroundColor: "#0ea5e9"
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        label: (context) => `${context.dataset.label}: ${context.parsed.y}`
                                    }
                                }
                            },
                            scales: {
                                x: { ticks: { autoSkip: false } },
                                y: { beginAtZero: true, ticks: { precision: 0 } }
                            }
                        }
                    });
                }

                const tagEntries = Array.from(tagCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10);
                if (tagEntries.length > 0) {
                    buildChart(tagCtx, {
                        type: "bar",
                        data: {
                            labels: tagEntries.map(([tag]) => tag),
                            datasets: [
                                {
                                    label: "Accepted Count",
                                    data: tagEntries.map(([, count]) => count),
                                    backgroundColor: paletteCycle("slate", tagEntries.length)
                                }
                            ]
                        },
                        options: {
                            indexAxis: "y",
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { beginAtZero: true },
                                y: { ticks: { autoSkip: false } }
                            }
                        }
                    });
                }

                const lastUpdated = new Date().toLocaleString();
                statusEl.textContent = `Last updated: ${lastUpdated}`;
            } catch (err) {
                statusEl.textContent = `Failed to load data: ${err.message}`;
                console.error(err);
            }
        };

        init();
    })();
</script>